ğŸ’» Bitwise Operators

ğŸ¯ Aim

To perform bitwise operations and demonstrate how to set and reset a specific bit in an integer.

ğŸ“š Theory

ğŸ”¹ Bitwise operators operate directly on the binary representation of integers. They are essential for tasks like flag manipulation, low-level programming, and performance optimization.

ğŸ”¹ Bitwise AND (&) sets each bit to 1 only if both corresponding bits are 1.
ğŸ‘‰ Example: 5 & 3 â†’ 0101 & 0011 = 0001 â†’ Result: 1

ğŸ”¹ Bitwise OR (|) sets each bit to 1 if at least one of the corresponding bits is 1.
ğŸ‘‰ Example: 5 | 3 â†’ 0101 | 0011 = 0111 â†’ Result: 7

ğŸ”¹ Bitwise XOR (^) sets each bit to 1 only if the corresponding bits are different.
ğŸ‘‰ Example: 5 ^ 3 â†’ 0101 ^ 0011 = 0110 â†’ Result: 6

ğŸ”¹ Bitwise NOT (~) inverts all bits of an integer.
ğŸ‘‰ Example: ~5 â†’ ~0101 = ...1010 â†’ Result: -6 (in two's complement)

ğŸ”¹ Left Shift (<<) shifts bits to the left, multiplying the number by powers of 2.
ğŸ‘‰ Example: 5 << 1 â†’ 0101 << 1 = 1010 â†’ Result: 10

ğŸ”¹ Right Shift (>>) shifts bits to the right, dividing the number by powers of 2.
ğŸ‘‰ Example: 5 >> 1 â†’ 0101 >> 1 = 0010 â†’ Result: 2

ğŸ”¹ These operators are used within control structures like if, while, and switch to manipulate data efficiently.
ğŸ”¹ Bitwise operations are especially useful in scenarios where multiple flags or states are stored compactly in a single variable.

ğŸ§  Conclusion

Bitwise operators unlock a layer of programming precision that goes beyond standard arithmetic. Whether you're shifting bits or toggling flags, these operations empower efficient, low-level data handling. From optimizing performance to encoding logic with elegance bitwise mastery is a hidden superpower in every programmerâ€™s toolkit.âš™ï¸ğŸ’¡
